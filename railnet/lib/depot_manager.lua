local transport = require and require("railnet.lib.transport") or dofile("/railnet/lib/transport.lua")
transport.init()
local STATE = { depots = {}, trains = {}, queue = {}, policy = {}, health = {} }
local function now() return os.epoch("utc") end
local function rjson(p) if fs.exists(p) then local h=fs.open(p,"r"); local s=h.readAll(); h.close(); local ok,t=pcall(textutils.unserializeJSON,s); if ok then return t end end end
local function wjson(p,t) fs.makeDir(fs.getDir(p)); local h=fs.open(p,"w"); h.write(textutils.serializeJSON(t,true)); h.close() end
local POLICY_PATH="/railnet/etc/depot_policy.json"; local HEALTH_PATH="/railnet/var/train_health.json"
local function load_policy() STATE.policy=rjson(POLICY_PATH) or {} end; local function load_health() STATE.health=rjson(HEALTH_PATH) or {} end; local function save_health() wjson(HEALTH_PATH,STATE.health) end
load_policy(); load_health()
local function hget(tid) STATE.health[tid]=STATE.health[tid] or {failures=0,timeouts=0,last_service=0,last_seen=now()} return STATE.health[tid] end
local function hinc(tid, f) local h=hget(tid); h[f]=(h[f] or 0)+1; h.last_seen=now(); save_health(); return h end
local function hservice(tid) local h=hget(tid); h.failures=0; h.timeouts=0; h.last_service=now(); save_health() end
transport.subscribe("depot/hello", function(ev) if not ev or not ev.depot_id then return end local d=STATE.depots[ev.depot_id] or {id=ev.depot_id,name=ev.name or ev.depot_id,cap=ev.capacity or 0,free_trains={}} d.name=ev.name or d.name; d.cap=ev.capacity or d.cap; d.service=ev.service or {}; STATE.depots[ev.depot_id]=d end)
transport.subscribe("depot/train_register", function(ev) if not ev or not ev.depot_id or not ev.train_id then return end if STATE.trains[ev.train_id] then local t=STATE.trains[ev.train_id]; t.type=ev.type or t.type; t.depot_id=ev.depot_id or t.depot_id else STATE.trains[ev.train_id]={id=ev.train_id,type=ev.type or "cargo",depot_id=ev.depot_id,status="idle"} end local d=STATE.depots[ev.depot_id]; if d then local exists=false; for _,tid in ipairs(d.free_trains or {}) do if tid==ev.train_id then exists=true break end end d.free_trains=d.free_trains or {}; if not exists then table.insert(d.free_trains, ev.train_id) end end hget(ev.train_id) end)
transport.subscribe("depot/train_status", function(ev) if not ev or not ev.train_id then return end local t=STATE.trains[ev.train_id]; if not t then return end t.status=ev.status or t.status end)
local function pick_train(req) for dep_id,d in pairs(STATE.depots) do for i,tid in ipairs(d.free_trains or {}) do local t=STATE.trains[tid]; if t and t.status=="idle" and (req.type==nil or t.type==req.type) then table.remove(d.free_trains,i); return dep_id, tid end end end end
transport.subscribe("depot/request_train", function(req) if not req or not req.job_id then return end local dep_id,train_id=pick_train(req); if dep_id and train_id then STATE.trains[train_id].status="dispatch"; STATE.trains[train_id].job_id=req.job_id; transport.publish("depot/dispatch",{depot_id=dep_id,train_id=train_id,job_id=req.job_id,route=req.route}); transport.publish("depot/train_dispatched",{depot_id=dep_id,train_id=train_id,job_id=req.job_id}); transport.publish("train/command",{train_id=train_id,cmd="start",speed=1.0}) else table.insert(STATE.queue, req) end end)
local function try_assign_queued() local i=1 while i<=#STATE.queue do local req=STATE.queue[i]; local dep_id,train_id=pick_train(req); if dep_id and train_id then STATE.trains[train_id].status="dispatch"; STATE.trains[train_id].job_id=req.job_id; transport.publish("depot/dispatch",{depot_id=dep_id,train_id=train_id,job_id=req.job_id,route=req.route}); transport.publish("depot/train_dispatched",{depot_id=dep_id,train_id=train_id,job_id=req.job_id}); transport.publish("train/command",{train_id=train_id,cmd="start",speed=1.0}); table.remove(STATE.queue,i) else i=i+1 end end end
local function idle_count(depot_id, ttype) local d=STATE.depots[depot_id]; if not d then return 0 end local c=0 for _,tid in ipairs(d.free_trains or {}) do local t=STATE.trains[tid]; if t and t.status=="idle" and (not ttype or t.type==ttype) then c=c+1 end end return c end
local function autopark_if_needed(depot_id) local policy=STATE.policy[depot_id] or {} for ttype,target in pairs((policy.idle_targets or policy)) do if type(target)=="number" then local idle=idle_count(depot_id,ttype) if idle>target then local d=STATE.depots[depot_id]; local need=idle-target; local i=1 while d and d.free_trains and i<=#(d.free_trains) and need>0 do local tid=d.free_trains[i]; local t=STATE.trains[tid]; if t and t.status=="idle" and t.type==ttype then transport.publish("depot/park",{depot_id=depot_id,train_id=tid}); need=need-1 end i=i+1 end end end end end
transport.subscribe("depot/train_idle", function(ev) if not ev or not ev.train_id then return end local t=STATE.trains[ev.train_id]; if not t then return end t.status="idle"; t.job_id=nil; local d=STATE.depots[t.depot_id]; if d then local exists=false; for _,tid in ipairs(d.free_trains or {}) do if tid==t.id then exists=true break end end d.free_trains=d.free_trains or {}; if not exists then table.insert(d.free_trains, t.id) end end try_assign_queued(); autopark_if_needed(t.depot_id) end)
transport.subscribe("service/request", function(ev) if not ev or not ev.train_id then return end local t=STATE.trains[ev.train_id]; if not t then return end t.status="service"; transport.publish("depot/service_route",{depot_id=t.depot_id,train_id=t.id,reason=ev.reason}) end)
transport.subscribe("cargo/job_failed", function(ev) if not ev then return end local tid=ev.train_id; if tid and STATE.trains[tid] then local h=hinc(tid,(tostring(ev.reason or ""):match("timeout") and "timeouts" or "failures")); local dep_id=STATE.trains[tid].depot_id; local pol=(dep_id and STATE.policy[dep_id]) or {}; local svc=pol.service or {}; local max_fail=tonumber(svc.max_failures or 3); local max_to=tonumber(svc.max_timeouts or 2); if (h.failures or 0)>=max_fail or (h.timeouts or 0)>=max_to then transport.publish("service/request",{train_id=tid,reason="auto:health"}); hservice(tid) end end end)
transport.subscribe("cargo/job_done", function(ev) for tid,t in pairs(STATE.trains) do if t.job_id==ev.id then local h=hget(tid); h.failures=math.max(0,(h.failures or 0)-1); h.timeouts=math.max(0,(h.timeouts or 0)-1); save_health(); break end end end)
print("DepotManager aktiv"); while true do os.pullEvent() end
